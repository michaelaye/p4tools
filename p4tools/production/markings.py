# AUTOGENERATED! DO NOT EDIT! File to edit: ../../notebooks/05b_production.markings.ipynb.

# %% auto 0
__all__ = ['LOGGER', 'IMG_X_SIZE', 'IMG_Y_SIZE', 'IMG_SHAPE', 'GOLD_MEMBERS', 'GOLD_PLOT_COLORS', 'set_subframe_size',
           'calc_fig_size', 'TileID', 'calc_blotchiness', 'Fnotch']

# %% ../../notebooks/05b_production.markings.ipynb 2
from . import io
from ..markings import Blotch,Fan

import logging
import matplotlib.pyplot as plt
import itertools
import pandas as pd


LOGGER = logging.getLogger(__name__)

# %% ../../notebooks/05b_production.markings.ipynb 3
IMG_X_SIZE = 840
IMG_Y_SIZE = 648

IMG_SHAPE = (IMG_Y_SIZE, IMG_X_SIZE)

GOLD_MEMBERS = ['michaelaye', 'mschwamb', 'Portyankina']  # 'CJ-DPI']
GOLD_PLOT_COLORS = list('bmg')

# %% ../../notebooks/05b_production.markings.ipynb 4
def set_subframe_size(ax):
    """Set plot view limit on Planet 4 subframe size."""
    ax.set_xlim(0, IMG_X_SIZE)
    ax.set_ylim(IMG_Y_SIZE, 0)

def calc_fig_size(width):
    """Calc figure height in ratio of subframes."""
    ratio = IMG_X_SIZE / IMG_Y_SIZE
    return (width, width / ratio)

# %% ../../notebooks/05b_production.markings.ipynb 5
class TileID:

    """Manage Planet 4 Image ids, getting data, plot stuff etc.

    At init this class will get the data for the given `imgid` using either the latest
    found database file or the optionally provided one.
    Parameters
    ----------
    imgid : str
        Planet4 image_id
    dbname : str, optional
        Filepath to database name. The marking data for `imgid` will be extracted.
        Default: Latest one.
    data : pd.DataFrame, optional
        If the data was already extracted before init, it can be provided here.
    image_name : str, optional
        The name of the image associated with the `imgid`.
        Default: None.
    scope : str, optional
        The scope of the image data. Default: 'planet4'.
    """

    def __init__(self, imgid, scope='planet4', dbname=None, data=None, image_name=None):
        self.imgid = io.check_and_pad_id(imgid)
        self._data = data
        self.scope = scope
        self.dbname = dbname
        self._image_name = image_name

    @property
    def data(self):
        if self._data is not None:
            return self._data
        try:
            db = io.DBManager(self.dbname)
            self._data = db.get_image_id_markings(self.imgid, self.image_name)
            return self._data
        except NoFilesFoundError:
            print("Cannot find PlanetFour database.")
            return None

    @property
    def image_name(self):
        "Return the name of the image i.e. the HiRISE ID"
        if self._image_name is None:
            db = io.DBManager(self.dbname)
            self._image_name = db.get_obsid_for_tile_id(self.imgid)
        return self._image_name

    @property
    def tile_coords(self):
        "The Coordinates for the tiles in x and y"
        return self.data[['x_tile', 'y_tile']].drop_duplicates().values[0]

    @property
    def blotchmask(self):
        """
        Check if the marking is 'blotch'.
        Returns
        -------
        pandas.Series
            A boolean series indicating rows where the 'marking' column is 'blotch'.
        """
        
        return self.data.marking == 'blotch'

    @property
    def fanmask(self):
        """
        Check if the marking is a 'fan'
        Returns
        -------
        pandas.Series
            A boolean series indicating rows where the 'marking' column is 'fan'.
        """
        return self.data.marking == 'fan'

    @property
    def n_marked_classifications(self):
        return self.data[self.blotchmask | self.fanmask].classification_id.nunique()

    @property
    def subframe(self):
        "np.array : Get tile url and return image tile using io funciton."
        url = self.data.iloc[0].image_url
        return io.get_subframe(url)

    def filter_data(self, kind, user_name=None, without_users=None):
        """Filter and return data for kind, user, or without_users.

        Parameters
        ----------
        kind : {'fan', 'blotch'}
            Marking
        user_name : str
            Filter data further for `user_name`
        without_users : list(strings)
            Only return data that is not in list of user_names (useful for non-gold data)
        """
        mask = self.data.marking == kind
        if user_name is not None:
            mask = (mask) & (self.data.user_name == user_name)
        if without_users is not None:
            mask = (mask) & (~self.data.user_name.isin(without_users))
        return self.data[mask]

    def get_fans(self, user_name=None, without_users=None):
        """Return data for fan markings."""
        return self.filter_data('fan', user_name, without_users)

    def get_blotches(self, user_name=None, without_users=None):
        """Return data for blotch markings."""
        return self.filter_data('blotch', user_name, without_users)

    def show_subframe(self, ax=None, aspect='auto'):
        "Plot the image of a tile"
        if ax is None:
            fig, ax = plt.subplots(figsize=calc_fig_size(8))
        ax.imshow(self.subframe, origin='upper', aspect=aspect)
        ax.set_axis_off()

    def plot_objects(self, objects, n=None, img=True, ax=None,
                     user_color=None, user_colors=None, wind_pointer=False):
        """
        Plot either fans or blotches with p4 subframe background.
        Parameters
        ----------
        objects : list
            List of objects to plot. Each object should have a `plot` method.
        n : int, optional
            Number of objects to plot. If None, all objects are plotted.
        img : bool, optional
            If True, plot the background image. Default is True.
        ax : matplotlib.axes.Axes, optional
            Matplotlib axis to plot on. If None, a new axis is created.
        user_color : str or tuple, optional
            Color to use for all objects. If None, colors are cycled.
        user_colors : list, optional
            List of colors to cycle through for each object. If None, a default color palette is used.
        wind_pointer : bool, optional
            If True, add a mean wind pointer for objects of type `Fan`. Default is False.
        Returns
        -------
        None
        """

        LOGGER.debug("Entering markings.plot_objects")
        LOGGER.debug("Received %i objects to plot.", len(objects))
        if ax is None:
            _, ax = plt.subplots(figsize=calc_fig_size(8))
            LOGGER.debug("Created own axis.")
        if img:
            LOGGER.debug("Plotting background image.")
            self.show_subframe(ax)
        counter = 0
        if user_colors is None:
            colors = itertools.cycle(sns.color_palette('bright', 12))
        else:
            colors = user_colors
        for obj, color in zip(objects, colors):
            if user_color is not None:
                color = user_color
            obj.plot(color=color, ax=ax)
            if wind_pointer is True and isinstance(obj, Fan):
                obj.add_mean_wind_pointer(color=color, ax=ax)
            counter += 1
            if counter == n:
                break
        set_subframe_size(ax)
        ax.set_axis_off()

    def pop_kwargs(self, kwargs):
        with_center = kwargs.pop('with_center', False)
        user_name = kwargs.pop('user_name', None)
        without_users = kwargs.pop('without_users', None)
        lw = kwargs.pop('lw', 1)
        return with_center, user_name, without_users, lw

    def plot_markings(self, kind, data=None, **kwargs):
        """General plotting method for both fans and blotches.

        Also accepts any derived set of objects in the `data` parameter.

        Parameters:
        ----------
        kind : {'blotch','fan'}
            Switch between specialized plotting features
        **kwargs : {dict}
            Any keywords to hand down to other methods here and/or matplotlib
        data : {list, pd.core.frame.DataFrame}, optional
            Any marking objects related to this image_id (the default is None, which will plot the raw data.)

        """
        with_center, user_name, without_users, lw = self.pop_kwargs(kwargs)
        if data is None:
            data = self.filter_data(kind, user_name, without_users)
        markingClass = Blotch if kind == 'blotch' else Fan
        if type(data) == pd.core.frame.DataFrame:
            data = [markingClass(i, self.scope, with_center=with_center, lw=lw)
                    for _, i in data.iterrows()]
        self.plot_objects(data, **kwargs)

    def plot_blotches(self, data=None, **kwargs):
        "Plot blotches within the TileID"
        self.plot_markings('blotch', data=data, **kwargs)

    def plot_fans(self, data=None, **kwargs):
        "Plot fans within the TileID"
        self.plot_markings('fan', data=data, **kwargs)

    def plot_all(self, savedir=None):
        """
        Plots various subframes and markings on a 2x2 grid of subplots.
        Parameters
        ----------
        savedir : str or pathlib.Path, optional
            Directory where the plot image will be saved. If None, the plot is not saved.
        Returns
        -------
        None
        """
        
        fig, axes = plt.subplots(2, 2)
        axes = axes.ravel()
        for i in [0, 2]:
            self.show_subframe(ax=axes[i])
        self.plot_fans(ax=axes[1])
        self.plot_blotches(ax=axes[3])
        for ax in axes:
            ax.set_axis_off()
        # fig.subplots_adjust(left=None, top=None, bottom=None, right=None,
                            # wspace=1e-3, hspace=1e-3)
        fig.suptitle(self.imgid)
        if savedir is not None:
            savepath = savedir / f"{self.imgid}.png"
            fig.savefig(savepath, dpi=150)


def calc_blotchiness(nfans, nblotches):
    """Calculate the fnotch value (or fan-ness)."""
    return (nblotches) / (nfans + nblotches)

# %% ../../notebooks/05b_production.markings.ipynb 6
class Fnotch(object):

    """Manage Fnotch by providing a cut during output.

    Parameters
    ----------
    fan : pandas.Series
        data set containing all required for Fan object (see `Fan`)
    blotch : pandas.Series
        data set containing all required for Blotch object (see `Blotch`)
    scope : str, optional
        the scope in which the coordinates are calculated (default is 'planet4')


    """
    def __init__(self, fan, blotch, scope='planet4'):
        self.fan = fan
        self.blotch = blotch
        self.scope = scope

        self.data = pd.concat([fan, blotch], ignore_index=True)
        self.data.index = ['fan', 'blotch']
        blotchiness = calc_blotchiness(fan.iloc[0]['n_votes'],
                                       blotch.iloc[0]['n_votes'])
        self.data.loc['fan', 'vote_ratio'] = (1 - blotchiness) + 0.01
        self.data.loc['blotch', 'vote_ratio'] = blotchiness - 0.01

    @classmethod
    def from_series(cls, series, scope):
        "Create Fnotch instance from series with fan_ and blotch_ indices."
        fan = Fan(series.filter(regex='fan_').rename(lambda x: x[4:]),
                  scope=scope)
        blotch = Blotch(series.filter(regex='blotch_').rename(lambda x: x[7:]),
                        scope=scope)
        return cls(series.fnotch_value, fan, blotch, scope)


    def apply_cut(self, cut):
        """Return the right marking, depending on cut value.

        If the cut is at 0.8, the fnotch value has to be equal or better before
        we assign the fan to the Fnotch object. Otherwise we return a blotch.

        Parameters
        ----------
        cut : float
            Level where we separate fan from blotch

        Returns
        -------
        `Fan` or `Blotch` object, depending on `cut`
        """
        row = self.data[self.data.vote_ratio > cut]
        return row
#         Marking = getattr(markings, row.index[0].title())
#         return Marking(row)

    def __repr__(self):
        return self.data.__repr__()

    def store(self, fpath=None):
        out = pd.concat([self.fanstore, self.blotchstore])
        out['fnotch_value'] = self.value
        if fpath is not None:
            out.to_hdf(str(fpath.with_suffix('.hdf')), 'df')
        return out

